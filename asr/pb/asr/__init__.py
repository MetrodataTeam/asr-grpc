# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: asr.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
  TYPE_CHECKING,
  Dict,
  List,
  Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
  import grpclib.server
  from betterproto.grpc.grpclib_client import MetadataLike
  from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class VadOptions(betterproto.Message):
  threshold: Optional[float] = betterproto.float_field(1, optional=True)
  """
    defaults from faster-whisper
     threshold: float = 0.5
     neg_threshold: float = None
     min_speech_duration_ms: int = 0
     max_speech_duration_s: float = float("inf")
     min_silence_duration_ms: int = 2000
     speech_pad_ms: int = 400
    """

  neg_threshold: Optional[float] = betterproto.float_field(2, optional=True)
  min_speech_duration_ms: Optional[int] = betterproto.uint32_field(
    3, optional=True
  )
  max_speech_duration_s: Optional[float] = betterproto.float_field(
    4, optional=True
  )
  min_silence_duration_ms: Optional[int] = betterproto.uint32_field(
    5, optional=True
  )
  speech_pad_ms: Optional[int] = betterproto.uint32_field(6, optional=True)


@dataclass(eq=False, repr=False)
class Audio(betterproto.Message):
  info: Optional[str] = betterproto.string_field(2, optional=True)
  """for debug/logging usage"""

  data: bytes = betterproto.bytes_field(1)
  initial_prompt: Optional[str] = betterproto.string_field(3, optional=True)
  """
    https://github.com/SYSTRAN/faster-whisper/blob/master/faster_whisper/transcribe.py#L184
    """

  language: Optional[str] = betterproto.string_field(4, optional=True)
  min_silence_duration_ms: Optional[int] = betterproto.uint32_field(
    5, optional=True
  )
  vad_filter: Optional[bool] = betterproto.bool_field(6, optional=True)
  numpy_data: Optional[bool] = betterproto.bool_field(7, optional=True)
  vad_options: Optional['VadOptions'] = betterproto.message_field(
    8, optional=True
  )


@dataclass(eq=False, repr=False)
class Info(betterproto.Message):
  language: str = betterproto.string_field(1)
  probability: float = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class Segment(betterproto.Message):
  start: float = betterproto.float_field(1)
  end: float = betterproto.float_field(2)
  text: str = betterproto.string_field(3)
  no_speech_prob: float = betterproto.float_field(4)


@dataclass(eq=False, repr=False)
class AudioResponse(betterproto.Message):
  text: str = betterproto.string_field(1)
  info: 'Info' = betterproto.message_field(2)
  segments: List['Segment'] = betterproto.message_field(3)


class AsrServiceStub(betterproto.ServiceStub):
  async def transcribe(
    self,
    audio: 'Audio',
    *,
    timeout: Optional[float] = None,
    deadline: Optional['Deadline'] = None,
    metadata: Optional['MetadataLike'] = None,
  ) -> 'AudioResponse':
    return await self._unary_unary(
      '/asr.ASRService/transcribe',
      audio,
      AudioResponse,
      timeout=timeout,
      deadline=deadline,
      metadata=metadata,
    )


class AsrServiceBase(ServiceBase):
  async def transcribe(self, audio: 'Audio') -> 'AudioResponse':
    raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

  async def __rpc_transcribe(
    self, stream: 'grpclib.server.Stream[Audio, AudioResponse]'
  ) -> None:
    request = await stream.recv_message()
    response = await self.transcribe(request)
    await stream.send_message(response)

  def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
    return {
      '/asr.ASRService/transcribe': grpclib.const.Handler(
        self.__rpc_transcribe,
        grpclib.const.Cardinality.UNARY_UNARY,
        Audio,
        AudioResponse,
      ),
    }
